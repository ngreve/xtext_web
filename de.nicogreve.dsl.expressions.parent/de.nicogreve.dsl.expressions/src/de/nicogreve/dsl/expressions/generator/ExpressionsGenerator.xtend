/*
 * generated by Xtext 2.18.0.M3
 */
package de.nicogreve.dsl.expressions.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import de.nicogreve.dsl.expressions.expressions.Model
import de.nicogreve.dsl.expressions.expressions.Instruction
import de.nicogreve.dsl.expressions.expressions.And
import de.nicogreve.dsl.expressions.expressions.Or
import de.nicogreve.dsl.expressions.expressions.Plus
import de.nicogreve.dsl.expressions.expressions.Minus
import de.nicogreve.dsl.expressions.expressions.Expo
import de.nicogreve.dsl.expressions.expressions.Mod
import de.nicogreve.dsl.expressions.expressions.MulOrDiv
import de.nicogreve.dsl.expressions.expressions.IntConstant
import de.nicogreve.dsl.expressions.expressions.Primary
import de.nicogreve.dsl.expressions.expressions.ArithmeticSigned
import de.nicogreve.dsl.expressions.expressions.Not
import de.nicogreve.dsl.expressions.expressions.Equality
import de.nicogreve.dsl.expressions.expressions.Comparison
import de.nicogreve.dsl.expressions.expressions.BoolConstant
import de.nicogreve.dsl.expressions.expressions.StringConstant
import de.nicogreve.dsl.expressions.expressions.VariableDeclaration
import de.nicogreve.dsl.expressions.expressions.VarRef
import de.nicogreve.dsl.expressions.expressions.Assignment
import de.nicogreve.dsl.expressions.expressions.PrintCommand

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ExpressionsGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var generatedCode= ""
		var model = resource.contents.head as Model
		
		for (e : model.instructions.filter(typeof (Instruction))) {
			generatedCode += e.compile + "\n"; 
		}
		
		fsa.generateFile("generated_code.js" , generatedCode)
	}
	
	def dispatch CharSequence compile(VariableDeclaration it) {
		'''var «name» = «initExp?.compile»'''
	}
	
	def dispatch CharSequence compile(VarRef it) {
		'''«ref.name»'''
	}
	
	def dispatch CharSequence compile(Assignment it) {
		'''«v.ref.name» = «exp.compile»'''
	}
	
	def dispatch CharSequence compile(And it) {
		'''«left.compile»&&«right.compile»'''
	}
	
	def dispatch CharSequence compile(Or it) {
		'''«left.compile»||«right.compile»'''
	}

	def dispatch CharSequence compile(Plus it) {
		'''«left.compile» + «right.compile»'''
	}
	
	def dispatch CharSequence compile(Minus it) {
		'''«left.compile» - «right.compile»'''
	}
	
	def dispatch CharSequence compile(Expo it) {
		'''«left.compile» ** «right.compile»'''
	}
	
	def dispatch CharSequence compile(Mod it) {
		'''«left.compile» % «right.compile»'''
	}
	
	def dispatch CharSequence compile(MulOrDiv it) {
		'''«left.compile» «op» «right.compile»'''
	}
	
	def dispatch CharSequence compile(IntConstant it) {
		'''«value.toString»'''
	}
	
	def dispatch CharSequence compile(Primary it) {
		'''(«expr.compile»)'''
	}
	
	def dispatch CharSequence compile(ArithmeticSigned it) {
		'''-«expression.compile»'''
	}
	
	def dispatch CharSequence compile(Not it) {
		'''!(«expression.compile»)'''
	}
	
	def dispatch CharSequence compile(Equality it) {
		'''«left.compile»«IF op.equals("==")»===«ELSE»!==«ENDIF»«right.compile»'''
	}
	
	def dispatch CharSequence compile(Comparison it) {
		'''«left.compile»«op»«right.compile»'''
	}
	
	def dispatch CharSequence compile(BoolConstant it) {
		'''«value»'''
	}
	
	def dispatch CharSequence compile(StringConstant it) {
		'''"«value»"'''
	}

	def dispatch CharSequence compile(PrintCommand it) {
		'''PRINT COMMAND NOT IMPLEMENTED'''
	}
	
		
	def dispatch CharSequence compile(Instruction it) {
		println("ERROR: Unsupported kind of Instruction in ExpressionsGenerator.compile()")
		'\n'
	}
}
